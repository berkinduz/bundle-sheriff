{"version":3,"sources":["../src/index.ts","../src/core/analyzer.ts","../src/core/config.ts","../src/reporters/cli-table.ts","../src/utils/format.ts"],"sourcesContent":["import cac from \"cac\";\nimport pc from \"picocolors\";\nimport { analyzePaths } from \"./core/analyzer\";\nimport { loadConfig, checkLimit } from \"./core/config\";\nimport { renderTable } from \"./reporters/cli-table\";\nimport type { CheckResult, BundleRule } from \"./types\";\n\nconst cli = cac(\"bundle-sheriff\");\n\nasync function runCheck(cwd: string) {\n  const config = await loadConfig(cwd);\n  if (!config || !Array.isArray(config.rules) || config.rules.length === 0) {\n    console.error(pc.red(\"No sheriff config found or no rules defined.\"));\n    process.exit(1);\n    return;\n  }\n\n  const results: CheckResult[] = [];\n  for (const rule of config.rules as BundleRule[]) {\n    const files = await analyzePaths(rule.path);\n    const compression = rule.compression ?? \"gzip\";\n    for (const f of files) {\n      const actual =\n        compression === \"raw\"\n          ? f.rawSize\n          : compression === \"brotli\"\n          ? f.brotliSize\n          : f.gzipSize;\n      const passed = checkLimit(actual, rule.maxSize);\n      results.push({\n        file: f.path,\n        compression,\n        actualSize: actual,\n        maxSize: rule.maxSize,\n        passed,\n      });\n    }\n  }\n\n  const output = renderTable(results);\n  console.log(output);\n\n  const anyFailed = results.some((r) => !r.passed);\n  process.exit(anyFailed ? 1 : 0);\n}\n\ncli\n  .command(\"check\", \"Check bundle budgets defined in sheriff.config\")\n  .option(\"--cwd <dir>\", \"Working directory\", { default: process.cwd() })\n  .action(async (opts: { cwd?: string }) => {\n    const cwd = opts.cwd || process.cwd();\n    await runCheck(cwd);\n  });\n\n// Default command: run check when no subcommand provided\ncli.command(\"\", \"Default: check budgets\").action(async () => {\n  await runCheck(process.cwd());\n});\n\ncli.help();\ncli.version(\"0.1.0\");\ncli.parse();\n","import { readFile } from \"node:fs/promises\";\nimport fg from \"fast-glob\";\nimport { gzipSizeSync } from \"gzip-size\";\nimport { sync as brotliSizeSync } from \"brotli-size\";\nimport type { FileStats } from \"../types\";\n\nexport async function getFileStats(filePath: string): Promise<FileStats> {\n  try {\n    const buffer = await readFile(filePath);\n    const gzip = gzipSizeSync(buffer);\n    const brotli = brotliSizeSync(buffer);\n\n    return {\n      path: filePath,\n      rawSize: buffer.length,\n      gzipSize: gzip,\n      brotliSize: brotli,\n    };\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    throw new Error(`Failed to analyze file '${filePath}': ${message}`);\n  }\n}\n\nexport async function analyzePaths(\n  pattern: string | string[]\n): Promise<FileStats[]> {\n  const patterns = Array.isArray(pattern) ? pattern : [pattern];\n  try {\n    const files = await fg(patterns, { absolute: true, dot: false });\n    const stats = await Promise.all(files.map(getFileStats));\n    return stats;\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    throw new Error(\n      `Failed to analyze paths for patterns ${JSON.stringify(\n        patterns\n      )}: ${message}`\n    );\n  }\n}\n","import { loadConfig as _loadConfig } from \"unconfig\";\nimport bytes from \"bytes\";\nimport type { SheriffConfig } from \"../types\";\n\nexport async function loadConfig(\n  cwd: string = process.cwd()\n): Promise<SheriffConfig> {\n  try {\n    const { config } = await _loadConfig<SheriffConfig>({\n      sources: [{ files: \"sheriff.config\" }],\n      cwd,\n    });\n\n    if (config && Array.isArray(config.rules)) {\n      return config;\n    }\n\n    return { rules: [] };\n  } catch (err) {\n    // If loading fails (missing file, parse error), surface a minimal default\n    return { rules: [] };\n  }\n}\n\nexport function checkLimit(actualSize: number, maxSizeStr: string): boolean {\n  const parsed = bytes(maxSizeStr);\n  if (typeof parsed !== \"number\" || !Number.isFinite(parsed) || parsed <= 0) {\n    throw new Error(\n      `Invalid maxSize '${maxSizeStr}'. Expected a size like '150kb'.`\n    );\n  }\n  return actualSize <= parsed;\n}\n","import Table from \"cli-table3\";\nimport pc from \"picocolors\";\nimport { formatBytes } from \"../utils/format\";\nimport type { CheckResult } from \"../types\";\n\nexport function renderTable(results: CheckResult[]): string {\n  const table = new Table({\n    head: [\"File\", \"Compression\", \"Actual\", \"Limit\", \"Passed\"],\n  });\n  for (const r of results) {\n    const passedText = r.passed ? pc.green(\"yes\") : pc.red(\"no\");\n    table.push([\n      r.file,\n      r.compression,\n      formatBytes(r.actualSize),\n      r.maxSize,\n      passedText,\n    ]);\n  }\n  return table.toString();\n}\n","import bytes from \"bytes\";\n\nexport function formatBytes(value: number): string {\n  if (!Number.isFinite(value) || value < 0) return \"n/a\";\n  return bytes(value, { unitSeparator: \" \" });\n}\n"],"mappings":"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","names":["pc","bytes","pc"]}